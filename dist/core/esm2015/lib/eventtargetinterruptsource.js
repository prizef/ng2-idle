import { Subscription, fromEvent, merge } from 'rxjs';
import { filter, throttleTime } from 'rxjs/operators';
import { InterruptArgs } from './interruptargs';
import { InterruptSource } from './interruptsource';
const defaultThrottleDelay = 500;
/*
 * An interrupt source on an EventTarget object, such as a Window or HTMLElement.
 */
export class EventTargetInterruptSource extends InterruptSource {
    constructor(target, events, options) {
        super(null, null);
        this.target = target;
        this.events = events;
        this.eventSubscription = new Subscription();
        if (typeof options === 'number') {
            options = { throttleDelay: options, passive: false };
        }
        options = options || {
            throttleDelay: defaultThrottleDelay,
            passive: false
        };
        if (options.throttleDelay === undefined || options.throttleDelay === null) {
            options.throttleDelay = defaultThrottleDelay;
        }
        this.throttleDelay = options.throttleDelay;
        this.passive = !!options.passive;
        const opts = this.passive ? { passive: true } : null;
        const fromEvents = events
            .split(' ')
            .map(eventName => fromEvent(target, eventName, opts));
        this.eventSrc = merge(...fromEvents);
        this.eventSrc = this.eventSrc.pipe(filter(innerArgs => !this.filterEvent(innerArgs)));
        if (this.throttleDelay > 0) {
            this.eventSrc = this.eventSrc.pipe(throttleTime(this.throttleDelay));
        }
        const handler = (innerArgs) => this.onInterrupt.emit(new InterruptArgs(this, innerArgs));
        this.attachFn = () => (this.eventSubscription = this.eventSrc.subscribe(handler));
        this.detachFn = () => this.eventSubscription.unsubscribe();
    }
    /*
     * Checks to see if the event should be filtered. Always returns false unless overriden.
     * @param event - The original event object.
     * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.
     */
    filterEvent(event) {
        return false;
    }
    /**
     * Returns the current options being used.
     * @return The current option values.
     */
    get options() {
        return { throttleDelay: this.throttleDelay, passive: this.passive };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnR0YXJnZXRpbnRlcnJ1cHRzb3VyY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JlL3NyYy9saWIvZXZlbnR0YXJnZXRpbnRlcnJ1cHRzb3VyY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFjLFlBQVksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdEQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQWtCcEQsTUFBTSxvQkFBb0IsR0FBRyxHQUFHLENBQUM7QUFFakM7O0dBRUc7QUFDSCxNQUFNLE9BQU8sMEJBQTJCLFNBQVEsZUFBZTtJQU03RCxZQUNZLE1BQVcsRUFDWCxNQUFjLEVBQ3hCLE9BQThDO1FBRTlDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFKUixXQUFNLEdBQU4sTUFBTSxDQUFLO1FBQ1gsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQU5sQixzQkFBaUIsR0FBaUIsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQVczRCxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUMvQixPQUFPLEdBQUcsRUFBRSxhQUFhLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsQ0FBQztTQUN0RDtRQUVELE9BQU8sR0FBRyxPQUFPLElBQUk7WUFDbkIsYUFBYSxFQUFFLG9CQUFvQjtZQUNuQyxPQUFPLEVBQUUsS0FBSztTQUNmLENBQUM7UUFFRixJQUFJLE9BQU8sQ0FBQyxhQUFhLEtBQUssU0FBUyxJQUFJLE9BQU8sQ0FBQyxhQUFhLEtBQUssSUFBSSxFQUFFO1lBQ3pFLE9BQU8sQ0FBQyxhQUFhLEdBQUcsb0JBQW9CLENBQUM7U0FDOUM7UUFFRCxJQUFJLENBQUMsYUFBYSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUM7UUFDM0MsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztRQUVqQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ3JELE1BQU0sVUFBVSxHQUFHLE1BQU07YUFDdEIsS0FBSyxDQUFDLEdBQUcsQ0FBQzthQUNWLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBTSxNQUFNLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDN0QsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUNoQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FDbEQsQ0FBQztRQUNGLElBQUksSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7U0FDdEU7UUFFRCxNQUFNLE9BQU8sR0FBRyxDQUFDLFNBQWMsRUFBRSxFQUFFLENBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksYUFBYSxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBRTVELElBQUksQ0FBQyxRQUFRLEdBQUcsR0FBRyxFQUFFLENBQ25CLENBQUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFFOUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDN0QsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxXQUFXLENBQUMsS0FBVTtRQUM5QixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFJLE9BQU87UUFDVCxPQUFPLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUN0RSxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24sIGZyb21FdmVudCwgbWVyZ2UgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZmlsdGVyLCB0aHJvdHRsZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBJbnRlcnJ1cHRBcmdzIH0gZnJvbSAnLi9pbnRlcnJ1cHRhcmdzJztcclxuaW1wb3J0IHsgSW50ZXJydXB0U291cmNlIH0gZnJvbSAnLi9pbnRlcnJ1cHRzb3VyY2UnO1xyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgZm9yIEV2ZW50VGFyZ2V0SW50ZXJydXB0U291cmNlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50VGFyZ2V0SW50ZXJydXB0T3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgdGhlIGV2ZW50cyBjb21pbmcgZnJvbSB0aGUgdGFyZ2V0LlxyXG4gICAqL1xyXG4gIHRocm90dGxlRGVsYXk/OiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIHVzZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycy5cclxuICAgKiBOb3RlOiB5b3UgbmVlZCB0byBkZXRlY3QgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgcGFzc2l2ZSBsaXN0ZW5lcnMsIGFuZCBvbmx5IHNldCB0aGlzIHRvIHRydWUgaWYgaXQgZG9lcy5cclxuICAgKi9cclxuICBwYXNzaXZlPzogYm9vbGVhbjtcclxufVxyXG5cclxuY29uc3QgZGVmYXVsdFRocm90dGxlRGVsYXkgPSA1MDA7XHJcblxyXG4vKlxyXG4gKiBBbiBpbnRlcnJ1cHQgc291cmNlIG9uIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgc3VjaCBhcyBhIFdpbmRvdyBvciBIVE1MRWxlbWVudC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFdmVudFRhcmdldEludGVycnVwdFNvdXJjZSBleHRlbmRzIEludGVycnVwdFNvdXJjZSB7XHJcbiAgcHJpdmF0ZSBldmVudFNyYzogT2JzZXJ2YWJsZTxhbnk+O1xyXG4gIHByaXZhdGUgZXZlbnRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcclxuICBwcm90ZWN0ZWQgdGhyb3R0bGVEZWxheTogbnVtYmVyO1xyXG4gIHByb3RlY3RlZCBwYXNzaXZlOiBib29sZWFuO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByb3RlY3RlZCB0YXJnZXQ6IGFueSxcclxuICAgIHByb3RlY3RlZCBldmVudHM6IHN0cmluZyxcclxuICAgIG9wdGlvbnM/OiBudW1iZXIgfCBFdmVudFRhcmdldEludGVycnVwdE9wdGlvbnNcclxuICApIHtcclxuICAgIHN1cGVyKG51bGwsIG51bGwpO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgb3B0aW9ucyA9IHsgdGhyb3R0bGVEZWxheTogb3B0aW9ucywgcGFzc2l2ZTogZmFsc2UgfTtcclxuICAgIH1cclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7XHJcbiAgICAgIHRocm90dGxlRGVsYXk6IGRlZmF1bHRUaHJvdHRsZURlbGF5LFxyXG4gICAgICBwYXNzaXZlOiBmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy50aHJvdHRsZURlbGF5ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy50aHJvdHRsZURlbGF5ID09PSBudWxsKSB7XHJcbiAgICAgIG9wdGlvbnMudGhyb3R0bGVEZWxheSA9IGRlZmF1bHRUaHJvdHRsZURlbGF5O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGhyb3R0bGVEZWxheSA9IG9wdGlvbnMudGhyb3R0bGVEZWxheTtcclxuICAgIHRoaXMucGFzc2l2ZSA9ICEhb3B0aW9ucy5wYXNzaXZlO1xyXG5cclxuICAgIGNvbnN0IG9wdHMgPSB0aGlzLnBhc3NpdmUgPyB7IHBhc3NpdmU6IHRydWUgfSA6IG51bGw7XHJcbiAgICBjb25zdCBmcm9tRXZlbnRzID0gZXZlbnRzXHJcbiAgICAgIC5zcGxpdCgnICcpXHJcbiAgICAgIC5tYXAoZXZlbnROYW1lID0+IGZyb21FdmVudDxhbnk+KHRhcmdldCwgZXZlbnROYW1lLCBvcHRzKSk7XHJcbiAgICB0aGlzLmV2ZW50U3JjID0gbWVyZ2UoLi4uZnJvbUV2ZW50cyk7XHJcbiAgICB0aGlzLmV2ZW50U3JjID0gdGhpcy5ldmVudFNyYy5waXBlKFxyXG4gICAgICBmaWx0ZXIoaW5uZXJBcmdzID0+ICF0aGlzLmZpbHRlckV2ZW50KGlubmVyQXJncykpXHJcbiAgICApO1xyXG4gICAgaWYgKHRoaXMudGhyb3R0bGVEZWxheSA+IDApIHtcclxuICAgICAgdGhpcy5ldmVudFNyYyA9IHRoaXMuZXZlbnRTcmMucGlwZSh0aHJvdHRsZVRpbWUodGhpcy50aHJvdHRsZURlbGF5KSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlciA9IChpbm5lckFyZ3M6IGFueSkgPT5cclxuICAgICAgdGhpcy5vbkludGVycnVwdC5lbWl0KG5ldyBJbnRlcnJ1cHRBcmdzKHRoaXMsIGlubmVyQXJncykpO1xyXG5cclxuICAgIHRoaXMuYXR0YWNoRm4gPSAoKSA9PlxyXG4gICAgICAodGhpcy5ldmVudFN1YnNjcmlwdGlvbiA9IHRoaXMuZXZlbnRTcmMuc3Vic2NyaWJlKGhhbmRsZXIpKTtcclxuXHJcbiAgICB0aGlzLmRldGFjaEZuID0gKCkgPT4gdGhpcy5ldmVudFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBldmVudCBzaG91bGQgYmUgZmlsdGVyZWQuIEFsd2F5cyByZXR1cm5zIGZhbHNlIHVubGVzcyBvdmVycmlkZW4uXHJcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cclxuICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIGV2ZW50IHNob3VsZCBiZSBmaWx0ZXJlZCAoZG9uJ3QgY2F1c2UgYW4gaW50ZXJydXB0KTsgb3RoZXJ3aXNlLCBmYWxzZS5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZmlsdGVyRXZlbnQoZXZlbnQ6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBvcHRpb25zIGJlaW5nIHVzZWQuXHJcbiAgICogQHJldHVybiBUaGUgY3VycmVudCBvcHRpb24gdmFsdWVzLlxyXG4gICAqL1xyXG4gIGdldCBvcHRpb25zKCk6IEV2ZW50VGFyZ2V0SW50ZXJydXB0T3B0aW9ucyB7XHJcbiAgICByZXR1cm4geyB0aHJvdHRsZURlbGF5OiB0aGlzLnRocm90dGxlRGVsYXksIHBhc3NpdmU6IHRoaXMucGFzc2l2ZSB9O1xyXG4gIH1cclxufVxyXG4iXX0=